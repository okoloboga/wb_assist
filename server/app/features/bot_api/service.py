"""
Bot API —Å–µ—Ä–≤–∏—Å –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å Telegram –±–æ—Ç–æ–º
"""

import logging
from typing import Dict, Any, Optional
from sqlalchemy.orm import Session
from app.features.wb_api.models import WBCabinet, WBOrder, WBProduct, WBStock, WBReview
from sqlalchemy import func, and_, or_, text
from datetime import datetime, timezone, timedelta
from app.features.wb_api.cache_manager import WBCacheManager
from app.features.wb_api.sync_service import WBSyncService
from .formatter import BotMessageFormatter

logger = logging.getLogger(__name__)


class BotAPIService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è Bot API"""
    
    def __init__(self, db: Session, cache_manager: WBCacheManager = None, sync_service: WBSyncService = None):
        self.db = db
        self.cache_manager = cache_manager or WBCacheManager(db)
        self.sync_service = sync_service or WBSyncService(db, self.cache_manager)
        self.formatter = BotMessageFormatter()

    async def get_user_by_telegram_id(self, telegram_id: int) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ telegram_id"""
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–π SQL –∑–∞–ø—Ä–æ—Å –≤–º–µ—Å—Ç–æ ORM
            result = self.db.execute(
                text("SELECT id, telegram_id, username, first_name, last_name, created_at FROM users WHERE telegram_id = :telegram_id"),
                {"telegram_id": telegram_id}
            ).fetchone()
            
            if not result:
                return None
            
            return {
                "id": result[0],
                "telegram_id": result[1],
                "username": result[2],
                "first_name": result[3],
                "last_name": result[4],
                "created_at": result[5]
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            return None

    async def get_user_cabinet(self, telegram_id: int) -> Optional[WBCabinet]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–∞–±–∏–Ω–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ telegram_id"""
        try:
            # –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user = await self.get_user_by_telegram_id(telegram_id)
            if not user:
                return None
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–∞–±–∏–Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            cabinet = self.db.query(WBCabinet).filter(
                WBCabinet.user_id == user["id"]
            ).first()
            
            return cabinet
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞–±–∏–Ω–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            return None

    async def get_dashboard(self, user: Dict[str, Any]) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞—à–±–æ—Ä–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            cabinet = await self.get_user_cabinet(user["telegram_id"])
            if not cabinet:
                return {
                    "success": False,
                    "error": "–ö–∞–±–∏–Ω–µ—Ç WB –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
            dashboard_data = await self._fetch_dashboard_from_db(cabinet)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Telegram —Å–æ–æ–±—â–µ–Ω–∏–µ
            telegram_text = self.formatter.format_dashboard(dashboard_data)
            
            return {
                "success": True,
                "data": dashboard_data,
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞—à–±–æ—Ä–¥–∞: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_recent_orders(self, user: Dict[str, Any], limit: int = 10, offset: int = 0) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∑–∞–∫–∞–∑–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            cabinet = await self.get_user_cabinet(user["telegram_id"])
            if not cabinet:
                return {
                    "success": False,
                    "error": "–ö–∞–±–∏–Ω–µ—Ç WB –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
            orders_data = await self._fetch_orders_from_db(cabinet, limit, offset)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Telegram —Å–æ–æ–±—â–µ–Ω–∏–µ
            telegram_text = self.formatter.format_orders(orders_data)
            
            return {
                "success": True,
                "data": orders_data,
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–∫–∞–∑–æ–≤: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_order_detail(self, user: Dict[str, Any], order_id: int) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π –∑–∞–∫–∞–∑–∞"""
        try:
            cabinet = await self.get_user_cabinet(user["telegram_id"])
            if not cabinet:
                return {
                    "success": False,
                    "error": "–ö–∞–±–∏–Ω–µ—Ç WB –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –ü–æ–ª—É—á–∞–µ–º –∑–∞–∫–∞–∑ –∏–∑ –ë–î
            order = self.db.query(WBOrder).filter(
                and_(
                    WBOrder.id == order_id,
                    WBOrder.cabinet_id == cabinet.id
                )
            ).first()
            
            if not order:
                return {
                    "success": False,
                    "error": "–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –∑–∞–∫–∞–∑–∞
            order_data = {
                "id": order.id,
                "date": order.order_date.isoformat() if order.order_date else None,
                "amount": order.total_price or 0,
                "product_name": order.name or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                "brand": order.brand or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                "warehouse_from": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",  # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ WBWarehouse
                "warehouse_to": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",    # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ WBWarehouse
                "commission_percent": order.commission_percent or 0.0,  # –†–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
                "commission_amount": order.commission_amount or 0.0,  # –†–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
                "rating": 0.0,  # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ WBReview
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞
                "order_id": order.order_id,
                "nm_id": order.nm_id,
                "article": order.article,
                "size": order.size,
                "barcode": order.barcode,
                "quantity": order.quantity,
                "price": order.price,
                "total_price": order.total_price,
                "order_date": order.order_date.isoformat() if order.order_date else None,
                "status": order.status,
                "created_at": order.created_at.isoformat()
            }
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Telegram —Å–æ–æ–±—â–µ–Ω–∏–µ
            telegram_text = self.formatter.format_order_detail({"order": order_data})
            
            return {
                "success": True,
                "data": order_data,
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –∑–∞–∫–∞–∑–∞: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_critical_stocks(self, user: Dict[str, Any], limit: int = 10, offset: int = 0) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ—Å—Ç–∞—Ç–∫–æ–≤"""
        try:
            cabinet = await self.get_user_cabinet(user["telegram_id"])
            if not cabinet:
                return {
                    "success": False,
                    "error": "–ö–∞–±–∏–Ω–µ—Ç WB –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
            stocks_data = await self._fetch_critical_stocks_from_db(cabinet, limit, offset)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Telegram —Å–æ–æ–±—â–µ–Ω–∏–µ
            telegram_text = self.formatter.format_critical_stocks_message(stocks_data)
            
            return {
                "success": True,
                "data": stocks_data,
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ—Å—Ç–∞—Ç–∫–æ–≤: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_reviews_summary(self, user: Dict[str, Any], limit: int = 10, offset: int = 0) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –ø–æ –æ—Ç–∑—ã–≤–∞–º"""
        try:
            cabinet = await self.get_user_cabinet(user["telegram_id"])
            if not cabinet:
                return {
                    "success": False,
                    "error": "–ö–∞–±–∏–Ω–µ—Ç WB –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
            reviews_data = await self._fetch_reviews_from_db(cabinet, limit, offset)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Telegram —Å–æ–æ–±—â–µ–Ω–∏–µ
            telegram_text = self.formatter.format_reviews_message(reviews_data)
            
            return {
                "success": True,
                "data": reviews_data,
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–∑—ã–≤–æ–≤: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_analytics_sales(self, user: Dict[str, Any], period: str = "7d") -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø—Ä–æ–¥–∞–∂"""
        try:
            cabinet = await self.get_user_cabinet(user["telegram_id"])
            if not cabinet:
                return {
                    "success": False,
                    "error": "–ö–∞–±–∏–Ω–µ—Ç WB –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
            analytics_data = await self._fetch_analytics_from_db(cabinet, period)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Telegram —Å–æ–æ–±—â–µ–Ω–∏–µ
            telegram_text = self.formatter.format_analytics_message(analytics_data)
            
            return {
                "success": True,
                "data": analytics_data,
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def start_sync(self, user: Dict[str, Any]) -> Dict[str, Any]:
        """–ó–∞–ø—É—Å–∫ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            logger.info(f"start_sync called with user: {user}")
            cabinet = await self.get_user_cabinet(user["telegram_id"])
            logger.info(f"cabinet: {cabinet}, type: {type(cabinet)}")
            if not cabinet:
                return {
                    "success": False,
                    "error": "–ö–∞–±–∏–Ω–µ—Ç WB –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é
            logger.info(f"Calling sync_all_data for cabinet {cabinet.id}")
            result = await self.sync_service.sync_all_data(cabinet)
            logger.info(f"sync_all_data result: {result}")
            
            if result["status"] == "success":
                return {
                    "success": True,
                    "data": result,
                    "telegram_text": "üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!"
                }
            else:
                return {
                    "success": False,
                    "error": result.get("error_message", "–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏")
                }
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_sync_status(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏"""
        try:
            status = await self.sync_service.get_sync_status()
            
            return {
                "success": True,
                "data": status,
                "telegram_text": f"üìä –°—Ç–∞—Ç—É—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {status.get('status', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}"
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def connect_cabinet(self, user: Dict[str, Any], api_key: str) -> Dict[str, Any]:
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ WB –∫–∞–±–∏–Ω–µ—Ç–∞"""
        try:
            logger.info(f"connect_cabinet called with user: {user}, api_key: {api_key}")
            logger.info(f"user type: {type(user)}")
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –∫–∞–±–∏–Ω–µ—Ç —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            existing_cabinet = self.db.query(WBCabinet).filter(
                WBCabinet.user_id == user["id"]
            ).first()
            if existing_cabinet:
                return {
                    "success": False,
                    "error": "Cabinet already connected"
                }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–∏ —É–∂–µ —ç—Ç–æ—Ç API –∫–ª—é—á
            existing_key = self.db.query(WBCabinet).filter(
                WBCabinet.api_key == api_key
            ).first()
            if existing_key:
                return {
                    "success": False,
                    "error": "API key already in use"
                }
            
            # –í–∞–ª–∏–¥–∏—Ä—É–µ–º API –∫–ª—é—á —á–µ—Ä–µ–∑ WB API
            logger.info(f"Creating WBAPIClient with api_key: {api_key}")
            from app.features.wb_api.client import WBAPIClient
            
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç –∫–∞–±–∏–Ω–µ—Ç–∞ –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
            temp_cabinet = WBCabinet(
                user_id=user["id"],
                api_key=api_key,
                name="temp",
                is_active=True
            )
            wb_client = WBAPIClient(temp_cabinet)
            logger.info(f"WBAPIClient created successfully")
            
            try:
                # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
                warehouses = await wb_client.get_warehouses()
                if not warehouses:
                    return {
                        "success": False,
                        "error": "Invalid API key"
                    }
            except Exception:
                return {
                    "success": False,
                    "error": "Invalid API key"
                }
            
            # –°–æ–∑–¥–∞–µ–º –∫–∞–±–∏–Ω–µ—Ç
            cabinet = WBCabinet(
                user_id=user["id"],
                api_key=api_key,
                name=f"WB Cabinet {user['telegram_id']}",
                is_active=True
            )
            
            self.db.add(cabinet)
            self.db.commit()
            self.db.refresh(cabinet)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            cabinet_data = {
                "cabinet_id": str(cabinet.id),
                "cabinet_name": cabinet.name,
                "api_key": api_key,
                "connected_at": cabinet.created_at.isoformat() if cabinet.created_at else None,
                "status": "connected",
                "api_key_status": "valid"
            }
            
            telegram_text = self.formatter.format_cabinet_connect_message(cabinet_data)
            
            return {
                "success": True,
                "data": cabinet_data,
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫–∞–±–∏–Ω–µ—Ç–∞: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def get_cabinet_status(self, user: Dict[str, Any]) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∫–∞–±–∏–Ω–µ—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–∞–±–∏–Ω–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            cabinets = self.db.query(WBCabinet).filter(
                WBCabinet.user_id == user["id"]
            ).all()
            
            if not cabinets:
                return {
                    "success": True,
                    "data": {
                        "cabinets": [],
                        "total_cabinets": 0,
                        "active_cabinets": 0,
                        "last_check": datetime.now(timezone.utc).isoformat()
                    },
                    "telegram_text": "üîë –°–¢–ê–¢–£–° WB –ö–ê–ë–ò–ù–ï–¢–û–í\n\n‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –∫–∞–±–∏–Ω–µ—Ç–æ–≤"
                }
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –∫–∞–±–∏–Ω–µ—Ç–æ–≤
            cabinet_data = []
            active_count = 0
            
            for cabinet in cabinets:
                if cabinet.is_active:
                    active_count += 1
                
                cabinet_data.append({
                    "id": f"cabinet_{cabinet.id}",
                    "name": cabinet.name or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç",
                    "status": "active" if cabinet.is_active else "inactive",
                    "api_key_status": "valid" if cabinet.is_active else "invalid",
                    "connected_at": cabinet.created_at.isoformat() if cabinet.created_at else None,
                    "last_sync": cabinet.last_sync_at.isoformat() if cabinet.last_sync_at else None
                })
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Telegram —Å–æ–æ–±—â–µ–Ω–∏–µ
            telegram_text = self.formatter.format_cabinet_status_message({"cabinets": cabinet_data})
            
            return {
                "success": True,
                "data": {
                    "cabinets": cabinet_data,
                    "total_cabinets": len(cabinets),
                    "active_cabinets": active_count,
                    "last_check": datetime.now(timezone.utc).isoformat()
                },
                "telegram_text": telegram_text
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∫–∞–±–∏–Ω–µ—Ç–æ–≤: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    async def _fetch_dashboard_from_db(self, cabinet: WBCabinet) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–∞—à–±–æ—Ä–¥–∞ –∏–∑ –ë–î"""
        try:
            now = datetime.now(timezone.utc)
            today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            yesterday_start = today_start - timedelta(days=1)
            
            # –¢–æ–≤–∞—Ä—ã
            total_products = self.db.query(WBProduct).filter(
                WBProduct.cabinet_id == cabinet.id
            ).count()
            
            active_products = self.db.query(WBProduct).filter(
                and_(
                    WBProduct.cabinet_id == cabinet.id,
                    WBProduct.is_active == True
                )
            ).count()
            
            critical_stocks = self.db.query(WBStock).filter(
                and_(
                    WBStock.cabinet_id == cabinet.id,
                    WBStock.quantity <= 5
                )
            ).count()
            
            # –ó–∞–∫–∞–∑—ã –∑–∞ —Å–µ–≥–æ–¥–Ω—è
            orders_today = self.db.query(WBOrder).filter(
                and_(
                    WBOrder.cabinet_id == cabinet.id,
                    WBOrder.order_date >= today_start,
                    WBOrder.status != 'canceled'
                )
            ).all()
            
            orders_yesterday = self.db.query(WBOrder).filter(
                and_(
                    WBOrder.cabinet_id == cabinet.id,
                    WBOrder.order_date >= yesterday_start,
                    WBOrder.order_date < today_start,
                    WBOrder.status != 'canceled'
                )
            ).all()
            
            today_count = len(orders_today)
            today_amount = sum(order.total_price or 0 for order in orders_today)
            yesterday_count = len(orders_yesterday)
            yesterday_amount = sum(order.total_price or 0 for order in orders_yesterday)
            
            # –†–æ—Å—Ç –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
            growth_percent = 0.0
            if yesterday_count > 0:
                growth_percent = ((today_count - yesterday_count) / yesterday_count) * 100
            
            # –û—Ç–∑—ã–≤—ã
            reviews = self.db.query(WBReview).filter(
                WBReview.cabinet_id == cabinet.id
            ).all()
            
            new_reviews = len([r for r in reviews if r.created_date and r.created_date >= today_start])
            unanswered_reviews = len([r for r in reviews if not r.is_answered])
            avg_rating = sum(r.rating or 0 for r in reviews) / len(reviews) if reviews else 0.0
            
            return {
                "cabinet_name": cabinet.name or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç",
                "last_sync": cabinet.last_sync_at.strftime("%d.%m.%Y %H:%M") if cabinet.last_sync_at else "–ù–∏–∫–æ–≥–¥–∞",
                "status": "–ê–∫—Ç–∏–≤–µ–Ω" if cabinet.is_active else "–ù–µ–∞–∫—Ç–∏–≤–µ–Ω",
                "products": {
                    "total": total_products,
                    "active": active_products,
                    "moderation": 0,  # –ó–∞–≥–ª—É—à–∫–∞
                    "critical_stocks": critical_stocks
                },
                "orders_today": {
                    "count": today_count,
                    "amount": today_amount,
                    "yesterday_count": yesterday_count,
                    "yesterday_amount": yesterday_amount,
                    "growth_percent": growth_percent
                },
                "stocks": {
                    "critical_count": critical_stocks,
                    "zero_count": self.db.query(WBStock).filter(
                        and_(
                            WBStock.cabinet_id == cabinet.id,
                            WBStock.quantity == 0
                        )
                    ).count(),
                    "attention_needed": critical_stocks,
                    "top_product": "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"  # –ó–∞–≥–ª—É—à–∫–∞
                },
                "reviews": {
                    "new_count": new_reviews,
                    "average_rating": round(avg_rating, 1),
                    "unanswered": unanswered_reviews,
                    "total": len(reviews)
                },
                "recommendations": ["–í—Å–µ –≤ –ø–æ—Ä—è–¥–∫–µ!"]  # –ó–∞–≥–ª—É—à–∫–∞
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–∞—à–±–æ—Ä–¥–∞: {e}")
            return {
                "cabinet_name": "–û—à–∏–±–∫–∞",
                "last_sync": "–û—à–∏–±–∫–∞",
                "status": "–û—à–∏–±–∫–∞",
                "products": {"total": 0, "active": 0, "moderation": 0, "critical_stocks": 0},
                "orders_today": {"count": 0, "amount": 0, "yesterday_count": 0, "yesterday_amount": 0, "growth_percent": 0.0},
                "stocks": {"critical_count": 0, "zero_count": 0, "attention_needed": 0, "top_product": "–û—à–∏–±–∫–∞"},
                "reviews": {"new_count": 0, "average_rating": 0.0, "unanswered": 0, "total": 0},
                "recommendations": ["–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö"]
            }

    async def _fetch_orders_from_db(self, cabinet: WBCabinet, limit: int, offset: int) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–∫–∞–∑–æ–≤ –∏–∑ –ë–î"""
        try:
            now = datetime.now(timezone.utc)
            today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
            yesterday_start = today_start - timedelta(days=1)
            
            # –ü–æ–ª—É—á–∞–µ–º –∑–∞–∫–∞–∑—ã —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
            orders_query = self.db.query(WBOrder).filter(
                and_(
                    WBOrder.cabinet_id == cabinet.id,
                    WBOrder.status != 'canceled'
                )
            ).order_by(WBOrder.order_date.desc())
            
            total_orders = orders_query.count()
            orders = orders_query.offset(offset).limit(limit).all()
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤
            orders_list = []
            for order in orders:
                orders_list.append({
                    "id": order.id,
                    "date": order.order_date.isoformat() if order.order_date else None,
                    "amount": order.total_price or 0,
                    "product_name": order.name or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    "brand": order.brand or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    "warehouse_from": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",  # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ WBWarehouse
                    "warehouse_to": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",    # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ WBWarehouse
                    "commission_percent": 0,  # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ WB API
                    "rating": 0  # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ WBReview
                })
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è
            orders_today = self.db.query(WBOrder).filter(
                and_(
                    WBOrder.cabinet_id == cabinet.id,
                    WBOrder.order_date >= today_start,
                    WBOrder.status != 'canceled'
                )
            ).all()
            
            orders_yesterday = self.db.query(WBOrder).filter(
                and_(
                    WBOrder.cabinet_id == cabinet.id,
                    WBOrder.order_date >= yesterday_start,
                    WBOrder.order_date < today_start,
                    WBOrder.status != 'canceled'
                )
            ).all()
            
            today_count = len(orders_today)
            today_amount = sum(order.total_price or 0 for order in orders_today)
            yesterday_count = len(orders_yesterday)
            yesterday_amount = sum(order.total_price or 0 for order in orders_yesterday)
            
            # –†–æ—Å—Ç –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
            growth_percent = 0.0
            if yesterday_count > 0:
                growth_percent = ((today_count - yesterday_count) / yesterday_count) * 100
            
            return {
                "orders": orders_list,
                "total_orders": total_orders,
                "statistics": {
                    "today_count": today_count,
                    "today_amount": today_amount,
                    "yesterday_count": yesterday_count,
                    "yesterday_amount": yesterday_amount,
                    "growth_percent": growth_percent,
                    "amount_growth_percent": 0.0,  # –ó–∞–≥–ª—É—à–∫–∞
                    "average_check": today_amount / today_count if today_count > 0 else 0
                },
                "pagination": {
                    "limit": limit,
                    "offset": offset,
                    "total": total_orders,
                    "has_more": (offset + limit) < total_orders
                }
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–∫–∞–∑–æ–≤: {e}")
            return {
                "orders": [],
                "total_orders": 0,
                "statistics": {"count": 0, "amount": 0, "yesterday_count": 0, "yesterday_amount": 0, "growth_percent": 0.0, "amount_growth_percent": 0.0, "average_check": 0.0},
                "pagination": {"limit": limit, "offset": offset, "total": 0, "has_more": False}
            }

    async def _fetch_critical_stocks_from_db(self, cabinet: WBCabinet, limit: int, offset: int) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ—Å—Ç–∞—Ç–∫–æ–≤ –∏–∑ –ë–î"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–≤–∞—Ä—ã —Å –∫—Ä–∏—Ç–∏—á–Ω—ã–º–∏ –æ—Å—Ç–∞—Ç–∫–∞–º–∏
            stocks_query = self.db.query(WBStock).filter(
                and_(
                    WBStock.cabinet_id == cabinet.id,
                    WBStock.quantity <= 5
                )
            ).order_by(WBStock.quantity.asc())
            
            total_stocks = stocks_query.count()
            stocks = stocks_query.offset(offset).limit(limit).all()
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –æ—Å—Ç–∞—Ç–∫–æ–≤
            stocks_list = []
            for stock in stocks:
                stocks_list.append({
                    "id": stock.id,
                    "nm_id": stock.nm_id,
                    "name": stock.name or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    "brand": stock.brand or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    "size": stock.size or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    "quantity": stock.quantity or 0,
                    "warehouse_name": stock.warehouse_name or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                    "last_updated": stock.last_updated.isoformat() if stock.last_updated else None
                })
            
            return {
                "stocks": stocks_list,
                "total_stocks": total_stocks,
                "pagination": {
                    "limit": limit,
                    "offset": offset,
                    "total": total_stocks
                }
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ—Å—Ç–∞—Ç–∫–æ–≤: {e}")
            return {
                "stocks": [],
                "total_stocks": 0,
                "pagination": {"limit": limit, "offset": offset, "total": 0}
            }

    async def _fetch_reviews_from_db(self, cabinet: WBCabinet, limit: int, offset: int) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–∑—ã–≤–æ–≤ –∏–∑ –ë–î"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–∑—ã–≤—ã
            reviews_query = self.db.query(WBReview).filter(
                WBReview.cabinet_id == cabinet.id
            ).order_by(WBReview.created_date.desc())
            
            total_reviews = reviews_query.count()
            reviews = reviews_query.offset(offset).limit(limit).all()
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –æ—Ç–∑—ã–≤–æ–≤
            reviews_list = []
            for review in reviews:
                reviews_list.append({
                    "id": review.id,
                    "nm_id": review.nm_id,
                    "review_id": review.review_id,
                    "text": review.text or "",
                    "rating": review.rating or 0,
                    "is_answered": review.is_answered,
                    "created_date": review.created_date.isoformat() if review.created_date else None
                })
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            new_reviews = len([r for r in reviews if r.created_date and r.created_date >= datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)])
            unanswered_reviews = len([r for r in reviews if not r.is_answered])
            avg_rating = sum(r.rating or 0 for r in reviews) / len(reviews) if reviews else 0.0
            
            return {
                "reviews": reviews_list,
                "total_reviews": total_reviews,
                "new_reviews": new_reviews,
                "unanswered_reviews": unanswered_reviews,
                "average_rating": round(avg_rating, 1),
                "pagination": {
                    "limit": limit,
                    "offset": offset,
                    "total": total_reviews
                }
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–∑—ã–≤–æ–≤: {e}")
            return {
                "reviews": [],
                "total_reviews": 0,
                "new_reviews": 0,
                "unanswered_reviews": 0,
                "average_rating": 0.0,
                "pagination": {"limit": limit, "offset": offset, "total": 0}
            }

    async def _fetch_analytics_from_db(self, cabinet: WBCabinet, period: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –∏–∑ –ë–î"""
        try:
            # –ó–∞–≥–ª—É—à–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∑–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–ª–æ–∂–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞
            return {
                "period": period,
                "sales": {
                    "total_amount": 0,
                    "total_orders": 0,
                    "average_order": 0
                },
                "products": {
                    "total": 0,
                    "active": 0,
                    "top_selling": "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
                },
                "reviews": {
                    "total": 0,
                    "average_rating": 0.0,
                    "unanswered": 0
                }
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏: {e}")
            return {
                "period": period,
                "sales": {"total_amount": 0, "total_orders": 0, "average_order": 0},
                "products": {"total": 0, "active": 0, "top_selling": "–û—à–∏–±–∫–∞"},
                "reviews": {"total": 0, "average_rating": 0.0, "unanswered": 0}
            }